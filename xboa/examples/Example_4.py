"""
\namespace xboa::examples::Example_4

Example code to read a file, apply a transformation and plot before and after

\include xboa/examples/Example_4.py
"""


#######################
# EXAMPLE 4           #
# IDEAL TRANSFER LINE #
#######################
#
# Load a data file; make some cuts
# transformation bunch train into single bunch data
# transform x x' distribution while keeping amplitude distribution constant 
# make some plots; write the data file out in a new format
# 

from xboa import *
from xboa.hit import Hit
from xboa.bunch import Bunch
import xboa.common as Common
import operator
import sys

#script starts here
target_beta  = 800.*Common.units['mm']
target_alpha = 0.0

print '========= XBOA example 4 ========='

print 
"""
Now we start manipulating the data. The idea here is to take particles from
one system, apply a match condition so that they can be used in another system.
Aim is to mimic an ideal transfer line.
"""
print "Loading file... "
bunch_list = Bunch.new_list_from_read_builtin('icool_for003', sys.prefix+'/share/xboa/data/for003_test.dat')
print "Loaded"

#I only use the last bunch for this
bunch = bunch_list[-1]

#let's look at the particles with 150 MeV < energy < 400 MeV
bunch.cut({'energy':400}, operator.ge)
bunch.cut({'energy':150}, operator.le)
#remove the outside of the beam - particles with amplitude > 90 mm (emittance > 22.5)
bunch.cut({'amplitude x y':90}, operator.ge)
bunch.root_scatter_graph('t', 'energy', 'ns', 'MeV', include_weightless=False)
#first we transform the bunch so that all particles sit in a single RF bucket
bunch.period_transformation( bunch[0]['t'], 0.20125*Common.units['GHz'])
bunch.root_scatter_graph('t', 'energy', 'ns', 'MeV', include_weightless=False)

#print out some information about longitudinal phase space
print "Longitudinal phase space covariance matrix\n",bunch.covariance_matrix(['t','energy'])
print 'Longitudinal RMS beta     ',bunch.get_beta(['ct']),'mm'
print 'Longitudinal RMS alpha    ',bunch.get_alpha(['ct'])
print 'Longitudinal RMS gamma    ',bunch.get_gamma(['ct']),'mm^{-1}'
print 'Longitudinal RMS emittance',bunch.get_emittance(['ct']),'mm'

#set to use geometric variables (like x,x')
#default is to use momentum variables (like x,px)
bunch.set_geometric_momentum(True) 

#calculate Twiss parameters and emittance for x, x' space
emit_trans = bunch.get_emittance(['x'])
print '\nInput phase space (x,x\') covariance matrix\n',bunch.covariance_matrix(['x','x\''])
print 'Input RMS beta     ',bunch.get_beta(['x']),'mm'
print 'Input RMS alpha    ',bunch.get_alpha(['x'])
print 'Input RMS gamma    ',bunch.get_gamma(['x']),'mm^{-1}'
print 'Input RMS emittance',bunch.get_emittance(['x']),'mm'

#plot x x' and amplitude distribution
bunch.root_scatter_graph('x', 'x\'', 'MeV/c', 'MeV/c', include_weightless=False)
bunch.root_histogram('amplitude x', 'mm')
#transform the transverse phase space to a new set of coordinates, conserving emittance
#for example, to remove an x-x' correlation into the beam
target_ellipse = Bunch.build_ellipse_2d(target_beta, target_alpha, emit_trans, bunch.mean(['p'])['p'], Common.pdg_pid_to_mass[13], True)
bunch.transform_to(['x','x\''], target_ellipse, mass_shell_variable='energy')

#print target Twiss parameters
print '\nNow I will make a transformation to target (x,x\') covariance matrix\n',target_ellipse
print 'Target RMS beta     ',target_beta,'mm'
print 'Target RMS alpha    ',target_alpha
print 'Target RMS gamma    ',(1.+target_alpha**2)/target_beta,'mm^{-1}'
print 'Transformation will conserve emittance by construction'
print

#print Twiss parameters of transformed distribution
print "Transformed phase space (x,x\') covariance matrix\n",bunch.covariance_matrix(['x','x\''])
print 'Transformed RMS beta     ',bunch.get_beta(['x']),'mm'
print 'Transformed RMS alpha    ',bunch.get_alpha(['x'])
print 'Transformed RMS gamma    ',bunch.get_gamma(['x']),'mm^{-1}'
print 'Transformed RMS emittance',bunch.get_emittance(['x']),'mm'

#plot x x' and amplitude distribution after - the point being that the x x' distribution is radically different,
#but the amplitude distribution is the same; what one would expect from an ideal transfer line
bunch.root_scatter_graph('x', 'x\'', 'MeV/c', 'MeV/c', include_weightless=False)
bunch.root_histogram('amplitude x', 'mm')

#translate to z=0
print 'Mean z at start',bunch.mean(['z'])['z']
bunch.translate({'z':-bunch.mean(['z'])['z']})
print 'Mean z at end  ',bunch.mean(['z'])['z']

#write out as an ICOOL for003 file
bunch.hit_write_builtin('icool_for003', 'for003_test.dat', 'for003 file generated by XBOA')

print 'Press <return> key to finish'
raw_input()
Bunch.clear_global_weights()




