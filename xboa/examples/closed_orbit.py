"""
\namespace xboa::examples::closed_orbit

Example code to find a closed orbit

\include xboa/examples/closed_orbit.py
"""

import numpy  
import xboa.common as common
from xboa.hit import Hit
from xboa.tracking import MatrixTracking
from xboa.algorithms import EllipseClosedOrbitFinder


def get_tracking_object():
    """
    Create a tracking object. This tracking object uses a list of matrices to
    generate tracking. The tracking goes like
    - x is a conventional phase space ellipse
    - y has phase advance of exactly pi
    - t has phase advance is complex i.e. on a resonance.
    Each cell or turn we advance through another transfer matrix. The closed 
    orbit is generated by a hard coded offset.

    Return value is a tuple consisting of a hit object on the closed_orbit and
    a tracking object that will propagate hit objects through the matrices.
    """
    number_of_turns = 5
    # x is conventional ellipse
    # y is phase advance = pi
    # t is phase advance = complex
    data = [[1.0,  0.5,  0.0,  0.0, 0.0,  0.0],
            [-0.5, 0.75, 0.0,  0.0, 0.0,  0.0],
            [0.0,  0.0,  0.0, -1.0, 0.0,  0.0],
            [0.0,  0.0,  1.0,  0.0, 0.0,  0.0],
            [0.0,  0.0,  0.0,  0.0, 2.0,  2.0],
            [0.0,  0.0,  0.0,  0.0, 2.0,  2.5]]
    matrix = numpy.matrix(data)
    matrix_list = [matrix**(i+1) for i in range(number_of_turns)]           
    offset = numpy.matrix([10., 7., 0., 0., 0., 1000.])
    offset_list = [offset]*number_of_turns
    offset_in = numpy.matrix([10., 7., 0., 0., 0., 1000.])
    tracking = MatrixTracking(matrix_list,
                              offset_list,
                              offset_in)
    closed_orbit_hit = Hit.new_from_dict({'x':10., 'px':7., 'energy':1000.,
                               'pid':2212, 'mass':common.pdg_pid_to_mass[2212]},
                               'pz')
    return closed_orbit_hit, tracking


def find_closed_orbit():
    """
    Find the closed orbit in x and y
    """
    print("""
    We start with a hit displaced from the closed orbit by 1 mm in x and y,
    track it through the lattice and examine the output, try to fit an ellipse
    to the output. The iteration finishes if either the signal noise is larger
    than the ellipse, we reach the numerical precision limit of the numpy
    library or we reach the maximum number of iterations (default 100).
    """)
    closed_orbit_hit, tracking = get_tracking_object()
    test_hit = closed_orbit_hit
    test_hit["x"] += 1.
    test_hit["y"] += 1.
    co_finder = EllipseClosedOrbitFinder(tracking, test_hit)
    co_generator = co_finder.find_closed_orbit_generator(["x", "x'"],
                                                         10,
                                                         max_iterations=10)
    canvas = None
    for i, my_co in enumerate(co_generator):
        print("gen", i)
        canvas, hist, ellipse, graph = my_co.plot_ellipse(
                                                   "x", "x'",
                                                   "mm", "", canvas=canvas)

if __name__ == "__main__":
    find_closed_orbit()
